// Generated by CoffeeScript 2.2.4
(function() {
  var BotApi, BotMaster, BotServant, TeleBot, adminUser, botMaster, botUtils, loadData, path, saveData, tulingApiKey,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },
    indexOf = [].indexOf;

  path = require("path");

  ({BotMaster, BotServant, BotApi, botUtils} = require("./index"));

  adminUser = process.argv[3];

  tulingApiKey = process.argv[4];

  saveData = function() {
    return botUtils.writeFileAsync("data.json", JSON.stringify(TeleBot.makeJSON(), null, "  ")).catch(botUtils.error);
  };

  loadData = function() {
    return botUtils.readFileAsync("data.json", "utf8").then(function(res) {
      return TeleBot.loadJSON(JSON.parse(res));
    }).catch(function(err) {
      TeleBot.morningList = {};
      TeleBot.morningDate = new Date();
      TeleBot.eveningList = {};
      TeleBot.eveningDate = new Date();
      TeleBot.echoList = [];
      TeleBot.echoText = null;
      return TeleBot.forwardList = [];
    });
  };

  TeleBot = (function() {
    class TeleBot extends BotServant {
      static loadJSON(json) {
        var k, ref, ref1, v;
        ref = json["morningList"];
        for (k in ref) {
          v = ref[k];
          TeleBot.morningList[k] = {
            "name": v["name"],
            "time": new Date(v["time"])
          };
        }
        TeleBot.morningDate = new Date(json["morningDate"]);
        ref1 = json["eveningList"];
        for (k in ref1) {
          v = ref1[k];
          TeleBot.eveningList[k] = {
            "name": v["name"],
            "time": new Date(v["time"])
          };
        }
        TeleBot.eveningDate = new Date(json["eveningDate"]);
        TeleBot.echoList = json["echoList"];
        TeleBot.echoText = json["echoText"];
        return TeleBot.forwardList = json["forwardList"];
      }

      static makeJSON() {
        var eveningDate, eveningList, k, morningDate, morningList, ref, ref1, v;
        morningList = {};
        ref = TeleBot.morningList;
        for (k in ref) {
          v = ref[k];
          morningList[k] = {
            "name": v["name"],
            "time": v["time"].getTime()
          };
        }
        morningDate = TeleBot.morningDate.getTime();
        eveningList = {};
        ref1 = TeleBot.eveningList;
        for (k in ref1) {
          v = ref1[k];
          eveningList[k] = {
            "name": v["name"],
            "time": v["time"].getTime()
          };
        }
        eveningDate = TeleBot.eveningDate.getTime();
        return {
          "morningList": morningList,
          "morningDate": morningDate,
          "eveningList": eveningList,
          "eveningDate": eveningDate,
          "echoList": TeleBot.echoList,
          "echoText": TeleBot.echoText,
          "forwardList": TeleBot.forwardList
        };
      }

      constructor(botApi, identifier, botName, botID) {
        super(botApi, identifier, botName, botID);
        this.onStart = this.onStart.bind(this);
        this.onHelp = this.onHelp.bind(this);
        this.onHello = this.onHello.bind(this);
        this.onEcho = this.onEcho.bind(this);
        this.onEchoChoice = this.onEchoChoice.bind(this);
        this.onDalao = this.onDalao.bind(this);
        this.onMorningList = this.onMorningList.bind(this);
        this.onMorning = this.onMorning.bind(this);
        this.onEveningList = this.onEveningList.bind(this);
        this.onEvening = this.onEvening.bind(this);
        this.onSleepTime = this.onSleepTime.bind(this);
        this.onChat = this.onChat.bind(this);
        this.onPhoto = this.onPhoto.bind(this);
        this.onDocument = this.onDocument.bind(this);
        this.onTime = this.onTime.bind(this);
        this.onCode = this.onCode.bind(this);
        this.onAddForward = this.onAddForward.bind(this);
        this.onRemoveForward = this.onRemoveForward.bind(this);
        this.onText = this.onText.bind(this);
        this.forwardUpdate = this.forwardUpdate.bind(this);
        this.addAllTextRouter = this.addAllTextRouter.bind(this);
        this.onReceiveText = this.onReceiveText.bind(this);
        this.updateEchoList = this.updateEchoList.bind(this);
        this.processUpdate = this.processUpdate.bind(this);
        this.counter = 0;
        this.textRouter = [];
        this.addAllTextRouter();
        this.handled = false;
      }

      onStart(update) {
        boundMethodCheck(this, TeleBot);
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], "欢迎，使用 /help 获取帮助列表。", {
            "reply_to_message_id": update["message"]["message_id"]
          });
        }).catch(botUtils.error);
      }

      onHelp(update) {
        var helpText;
        boundMethodCheck(this, TeleBot);
        helpText = "使用 /morning 向 Bot 说早安。\n使用 /evening 向 Bot 说晚安。\n使用 /morninglist 获取起床列表。\n使用 /eveninglist 获取晚安列表。\n使用 /sleeptime 让 Bot 计算您的睡眠时间。\n再次使用 /morning 和 /evening 会使 Bot 更新您的早安和晚安时间记录。\n早安记录列表在午夜 00:00 更新，晚安记录列表在傍晚 18:00 更新。\n遇到 Bug 提交 Issue 或者 Pull Request 请使用 /code 获取 GitHub Repo 地址。";
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], helpText, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        }).catch(botUtils.error);
      }

      onHello(update) {
        var helloList;
        boundMethodCheck(this, TeleBot);
        helloList = ["What's up?", "How do you do?", "Nice to meet you!", "A beautiful day always begins with a cup of JAVA.", "美好的一天，从一杯JAVA开始！", "天王盖地虎，地虎一米五；宝塔镇河妖，河妖长不高。"];
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], `Hello, ${update["message"]["from"]["first_name"]}! ${helloList[Math.floor(Math.random() * helloList.length)]}`, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        }).catch(botUtils.error);
      }

      onEcho(update) {
        var chatInfo, j, keyboard, len, ref;
        boundMethodCheck(this, TeleBot);
        if ((update["message"]["from"]["username"] == null) || update["message"]["from"]["username"] !== adminUser) {
          return;
        }
        this.constructor.echoText = update["message"]["text"].replace(new RegExp(`^/?[eE]cho(@${this.botName})?`), "");
        keyboard = [];
        ref = this.constructor.echoList;
        for (j = 0, len = ref.length; j < len; j++) {
          chatInfo = ref[j];
          keyboard.push([`echo#${chatInfo}`]);
        }
        keyboard.push(["echo#All"]);
        keyboard.push([
          {
            "text": "echo#Cancel"
          }
        ]);
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], "选择您想传达到哪个聊天", {
            "reply_to_message_id": update["message"]["message_id"],
            "reply_markup": {
              "keyboard": keyboard
            }
          });
        });
      }

      onEchoChoice(update) {
        var chatID, chatInfo, j, len, ref, text;
        boundMethodCheck(this, TeleBot);
        if ((update["message"]["from"]["username"] == null) || update["message"]["from"]["username"] !== adminUser) {
          return;
        }
        chatID = update["message"]["text"].split("#")[1];
        text = this.constructor.echoText;
        this.constructor.echoText = null;
        switch (chatID) {
          case "All":
            ref = this.constructor.echoList;
            for (j = 0, len = ref.length; j < len; j++) {
              chatInfo = ref[j];
              ((chatID) => {
                chatID = chatInfo.split("#")[0];
                return this.botApi.sendChatAction(chatID, "typing").then(() => {
                  return this.botApi.sendMessage(chatID, text);
                });
              })(chatID);
            }
            break;
          default:
            if (chatID !== "Cancel" && (chatID != null)) {
              this.botApi.sendChatAction(chatID, "typing").then(() => {
                return this.botApi.sendMessage(chatID, text);
              });
            }
        }
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], "OK.", {
            "reply_to_message_id": update["message"]["message_id"],
            "reply_markup": {
              "remove_keyboard": true
            }
          });
        });
      }

      onDalao(update) {
        boundMethodCheck(this, TeleBot);
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], "Dalao，膜！", {
            "reply_to_message_id": update["message"]["message_id"]
          });
        });
      }

      onMorningList(update) {
        var d, i, j, personArray, ref, text;
        boundMethodCheck(this, TeleBot);
        d = new Date();
        if (d.getTime() - d.getTimezoneOffset() * 60 * 1000 - (this.constructor.morningDate.getTime() - this.constructor.morningDate.getTimezoneOffset() * 60 * 1000 - (this.constructor.morningDate.getTime() - this.constructor.morningDate.getTimezoneOffset() * 60 * 1000) % (24 * 60 * 60 * 1000)) > 24 * 60 * 60 * 1000) {
          this.constructor.morningDate = d;
          this.constructor.morningList = {};
        }
        personArray = Object.values(this.constructor.morningList);
        if (personArray.length !== 0) {
          personArray.sort(function(o1, o2) {
            return o1["time"].getTime() - o2["time"].getTime();
          });
        }
        text = "";
        for (i = j = 0, ref = personArray.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          text += `${i + 1}. ${personArray[i]["name"]} ${(personArray[i]["time"].toTimeString().split(" ")[0])}\n`;
        }
        if (text.length === 0) {
          text = "大家都在赖床。";
        }
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], text, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        });
      }

      onMorning(update) {
        var d;
        boundMethodCheck(this, TeleBot);
        d = new Date();
        if (d.getTime() - d.getTimezoneOffset() * 60 * 1000 - (this.constructor.morningDate.getTime() - this.constructor.morningDate.getTimezoneOffset() * 60 * 1000 - (this.constructor.morningDate.getTime() - this.constructor.morningDate.getTimezoneOffset() * 60 * 1000) % (24 * 60 * 60 * 1000)) > 24 * 60 * 60 * 1000) {
          this.constructor.morningDate = d;
          this.constructor.morningList = {};
        }
        this.constructor.morningList[update["message"]["from"]["id"]] = {
          "name": update["message"]["from"]["first_name"],
          "time": d
        };
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], `你是今天第 ${(Object.keys(this.constructor.morningList).length)} 个起床的少年。`, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        });
      }

      onEveningList(update) {
        var d, i, j, personArray, ref, text;
        boundMethodCheck(this, TeleBot);
        d = new Date();
        // Refresh eveningList at 18:00 everyday.
        if (d.getTime() - d.getTimezoneOffset() * 60 * 1000 - (this.constructor.eveningDate.getTime() - this.constructor.eveningDate.getTimezoneOffset() * 60 * 1000 - (this.constructor.eveningDate.getTime() - this.constructor.eveningDate.getTimezoneOffset() * 60 * 1000) % (24 * 60 * 60 * 1000) + 18 * 60 * 60 * 1000) > 24 * 60 * 60 * 1000) {
          this.constructor.eveningDate = d;
          this.constructor.eveningList = {};
        }
        personArray = Object.values(this.constructor.eveningList);
        if (personArray.length !== 0) {
          personArray.sort(function(o1, o2) {
            return o1["time"].getTime() - o2["time"].getTime();
          });
        }
        text = "";
        for (i = j = 0, ref = personArray.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          text += `${i + 1}. ${personArray[i]["name"]} ${(personArray[i]["time"].toTimeString().split(" ")[0])}\n`;
        }
        if (text.length === 0) {
          text = "大家都在修仙。";
        }
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], text, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        });
      }

      onEvening(update) {
        var d;
        boundMethodCheck(this, TeleBot);
        d = new Date();
        // Refresh eveningList at 18:00 everyday.
        if (d.getTime() - d.getTimezoneOffset() * 60 * 1000 - (this.constructor.eveningDate.getTime() - this.constructor.eveningDate.getTimezoneOffset() * 60 * 1000 - (this.constructor.eveningDate.getTime() - this.constructor.eveningDate.getTimezoneOffset() * 60 * 1000) % (24 * 60 * 60 * 1000) + 18 * 60 * 60 * 1000) > 24 * 60 * 60 * 1000) {
          this.constructor.eveningDate = d;
          this.constructor.eveningList = {};
        }
        this.constructor.eveningList[update["message"]["from"]["id"]] = {
          "name": update["message"]["from"]["first_name"],
          "time": d
        };
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], `你是今天第 ${(Object.keys(this.constructor.eveningList).length)} 个睡觉的少年。`, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        });
      }

      onSleepTime(update) {
        var d, sleepHours, sleepMins, sleepMs, text;
        boundMethodCheck(this, TeleBot);
        d = new Date();
        if (d.getTime() - d.getTimezoneOffset() * 60 * 1000 - (this.constructor.morningDate.getTime() - this.constructor.morningDate.getTimezoneOffset() * 60 * 1000 - (this.constructor.morningDate.getTime() - this.constructor.morningDate.getTimezoneOffset() * 60 * 1000) % (24 * 60 * 60 * 1000)) > 24 * 60 * 60 * 1000) {
          this.constructor.morningDate = d;
          this.constructor.morningList = {};
        }
        // Refresh eveningList at 18:00 everyday.
        if (d.getTime() - d.getTimezoneOffset() * 60 * 1000 - (this.constructor.eveningDate.getTime() - this.constructor.eveningDate.getTimezoneOffset() * 60 * 1000 - (this.constructor.eveningDate.getTime() - this.constructor.eveningDate.getTimezoneOffset() * 60 * 1000) % (24 * 60 * 60 * 1000) + 18 * 60 * 60 * 1000) > 24 * 60 * 60 * 1000) {
          this.constructor.eveningDate = d;
          this.constructor.eveningList = {};
        }
        text = "";
        if (this.constructor.morningList.length === 0 || this.constructor.eveningList.length === 0) {
          text = "不好意思，这个 bot 是新来的，还没有足够的数据，请投喂。";
        } else if (this.constructor.eveningList[update["message"]["from"]["id"]] == null) {
          text = "Pia!!!骗谁呢你，你是要修仙吧！";
        } else if (this.constructor.morningList[update["message"]["from"]["id"]] == null) {
          text = "Pia!!!骗谁呢你，你还没起床呢！";
        } else {
          sleepMs = this.constructor.morningList[update["message"]["from"]["id"]]["time"] - this.constructor.eveningList[update["message"]["from"]["id"]]["time"];
          if (sleepMs < 0) {
            text = "Pia!!!骗谁呢你，你昨晚睡觉比今早起床还晚？？？";
            delete this.constructor.morningList[update["message"]["from"]["id"]];
            delete this.constructor.eveningList[update["message"]["from"]["id"]];
          } else {
            sleepHours = sleepMs / (60 * 60 * 1000);
            sleepMins = sleepMs % (60 * 60 * 1000) / (60 * 1000);
            text = `你昨晚睡了 ${Math.floor(sleepHours)} 小时 ${Math.floor(sleepMins)} 分钟。`;
          }
        }
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], text, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        });
      }

      onChat(update) {
        boundMethodCheck(this, TeleBot);
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return botUtils.getTuling(tulingApiKey, update["message"]["text"].replace(new RegExp(`^/?[cC]hat(@${this.botName})?`), ""), update["message"]["from"]["id"]);
        }).then((res) => {
          var j, len, r, results;
          results = [];
          for (j = 0, len = res.length; j < len; j++) {
            r = res[j];
            results.push(((r) => {
              return this.botApi.sendMessage(update["message"]["chat"]["id"], r["values"]["text"], {
                "reply_to_message_id": update["message"]["message_id"]
              });
            })(r));
          }
          return results;
        }).catch(botUtils.error);
      }

      onPhoto(update) {
        boundMethodCheck(this, TeleBot);
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "upload_photo").then(function() {
          return botUtils.readFileAsObj("./AlynxLogo.png");
        }).then((fileObj) => {
          return this.botApi.sendPhoto(update["message"]["chat"]["id"], fileObj, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        });
      }

      onDocument(update) {
        boundMethodCheck(this, TeleBot);
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "upload_document").then(function() {
          return botUtils.readFileAsObj("./AlynxLogo.png");
        }).then((fileObj) => {
          return this.botApi.sendDocument(update["message"]["chat"]["id"], fileObj, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        });
      }

      onTime(update) {
        boundMethodCheck(this, TeleBot);
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], Date(), {
            "reply_to_message_id": update["message"]["message_id"]
          });
        }).catch(botUtils.error);
      }

      onCode(update) {
        boundMethodCheck(this, TeleBot);
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], "https://github.com/AlynxZhou/coffee-telegram-bot/", {
            "reply_to_message_id": update["message"]["message_id"]
          });
        });
      }

      onAddForward(update) {
        var ref;
        boundMethodCheck(this, TeleBot);
        if ((update["message"]["from"]["username"] == null) || update["message"]["from"]["username"] !== adminUser) {
          return;
        }
        if (update["message"]["chat"]["type"] === "private") {
          return;
        }
        if (ref = update["message"]["chat"]["id"], indexOf.call(this.constructor.forwardList, ref) < 0) {
          this.constructor.forwardList.push(update["message"]["chat"]["id"]);
          return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
            return this.botApi.sendMessage(update["message"]["chat"]["id"], `已添加 ${update["message"]["chat"]["id"]}#${update["message"]["chat"]["title"]} 到转发列表。`, {
              "reply_to_message_id": update["message"]["message_id"]
            });
          }).catch(botUtils.error);
        }
      }

      onRemoveForward(update) {
        var chatID;
        boundMethodCheck(this, TeleBot);
        if ((update["message"]["from"]["username"] == null) || update["message"]["from"]["username"] !== adminUser) {
          return;
        }
        if (update["message"]["chat"]["type"] === "private") {
          return;
        }
        this.constructor.forwardList = (function() {
          var j, len, ref, results;
          ref = this.constructor.forwardList;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            chatID = ref[j];
            if (chatID !== update["message"]["chat"]["id"]) {
              results.push(chatID);
            }
          }
          return results;
        }).call(this);
        return this.botApi.sendChatAction(update["message"]["chat"]["id"], "typing").then(() => {
          return this.botApi.sendMessage(update["message"]["chat"]["id"], `已从转发列表中移除 ${update["message"]["chat"]["id"]}#${update["message"]["chat"]["title"]}。`, {
            "reply_to_message_id": update["message"]["message_id"]
          });
        }).catch(botUtils.error);
      }

      onText(regex, callback) {
        boundMethodCheck(this, TeleBot);
        return this.textRouter.push({
          "regex": regex,
          "callback": callback
        });
      }

      forwardUpdate(update) {
        var chatID, j, len, ref, results;
        boundMethodCheck(this, TeleBot);
        ref = this.constructor.forwardList;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          chatID = ref[j];
          results.push(((chatID) => {
            if (chatID !== update["message"]["chat"]["id"]) {
              return this.botApi.sendChatAction(chatID, "typing").then(() => {
                return this.botApi.forwardMessage(chatID, update["message"]["chat"]["id"], update["message"]["message_id"], {
                  "disable_notification": true
                });
              });
            }
          })(chatID));
        }
        return results;
      }

      addAllTextRouter() {
        boundMethodCheck(this, TeleBot);
        this.onText(new RegExp(`^/?[sS]tart(@${this.botName})?`), this.onStart);
        this.onText(new RegExp(`^/?[hH]elp(@${this.botName})?`), this.onHelp);
        this.onText(new RegExp(`^/?[hH]ello(@${this.botName})?`), this.onHello);
        this.onText(new RegExp("^echo#.+"), this.onEchoChoice);
        this.onText(new RegExp(`^/?[eE]cho(@${this.botName})?`), this.onEcho);
        this.onText(new RegExp(`^/?[dD]alao(@${this.botName})?`), this.onDalao);
        this.onText(new RegExp(`^/?[mM]orning[lL]ist(@${this.botName})?`), this.onMorningList);
        this.onText(new RegExp(`^/?[mM]orning(@${this.botName})?`), this.onMorning);
        this.onText(new RegExp(`^/?[eE]vening[lL]ist(@${this.botName})?`), this.onEveningList);
        this.onText(new RegExp(`^/?[eE]vening(@${this.botName})?`), this.onEvening);
        this.onText(new RegExp(`^/?[sS]leep[tT]ime(@${this.botName})?`), this.onSleepTime);
        this.onText(new RegExp(`^/?[cC]hat(@${this.botName})?`), this.onChat);
        this.onText(new RegExp(`^/?[pP]hoto(@${this.botName})?`), this.onPhoto);
        this.onText(new RegExp(`^/?[dD]ocument(@${this.botName})?`), this.onDocument);
        this.onText(new RegExp(`^/?[tT]ime(@${this.botName})?`), this.onTime);
        this.onText(new RegExp(`^/?[cC]ode(@${this.botName})?`), this.onCode);
        this.onText(new RegExp(`^/?[aA]dd[fF]orward(@${this.botName})?`), this.onAddForward);
        return this.onText(new RegExp(`^/?[rR]emove[fF]orward(@${this.botName})?`), this.onRemoveForward);
      }

      onReceiveText(update, counter) {
        var j, len, r, ref, results;
        boundMethodCheck(this, TeleBot);
        botUtils.log(`${this.botName}#${this.identifier}: Got No.${counter} text "${update["message"]["text"]}".`);
        ref = this.textRouter;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          r = ref[j];
          if (update["message"]["text"].match(r["regex"]) != null) {
            r["callback"](update);
            this.handled = true;
            break;
          } else {
            results.push(void 0);
          }
        }
        return results;
      }

      updateEchoList(update) {
        var ref, ref1, results;
        boundMethodCheck(this, TeleBot);
        switch (update["message"]["chat"]["type"]) {
          case "private":
            if (ref = `${update["message"]["chat"]["id"]}#${update["message"]["chat"]["first_name"]}`, indexOf.call(this.constructor.echoList, ref) < 0) {
              this.constructor.echoList.push(`${update["message"]["chat"]["id"]}#${update["message"]["chat"]["first_name"]}`);
            }
            break;
          default:
            if (ref1 = `${update["message"]["chat"]["id"]}#${update["message"]["chat"]["title"]}`, indexOf.call(this.constructor.echoList, ref1) < 0) {
              this.constructor.echoList.push(`${update["message"]["chat"]["id"]}#${update["message"]["chat"]["title"]}`);
            }
        }
        results = [];
        while (this.constructor.echoList.length > 7) {
          results.push(this.constructor.echoList.shift());
        }
        return results;
      }

      processUpdate(update) {
        var ref;
        boundMethodCheck(this, TeleBot);
        if (update["message"]) {
          this.handled = false;
          ++this.counter;
          this.updateEchoList(update);
          if (update["message"]["text"] != null) {
            this.onReceiveText(update, this.counter);
          }
          if ((!this.handled) && (ref = update["message"]["chat"]["id"], indexOf.call(this.constructor.forwardList, ref) >= 0) && update["message"]["from"]["id"] !== this.botID) {
            return this.forwardUpdate(update);
          }
        }
      }

    };

    TeleBot.morningList = {};

    TeleBot.morningDate = new Date();

    TeleBot.eveningList = {};

    TeleBot.eveningDate = new Date();

    TeleBot.echoList = [];

    TeleBot.echoText = null;

    TeleBot.forwardList = [];

    return TeleBot;

  }).call(this);

  botMaster = new BotMaster(new BotApi(process.argv[2]), TeleBot, botUtils.perFromID);

  botMaster.loop(loadData, saveData);

}).call(this);
